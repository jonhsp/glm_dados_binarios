---
title: "Trabalho 1: Regressão Logística - Proporção de Baixa Renda (RS)"
subtitle: "CE314 - Modelos Lineares Generalizados (Grupo 4)"
author: "jonathas Pereira,......"
output: 
  html_document:
    theme: journal
    number_sections: true
    code_folding: 'hide'
---
___ 


# Variáveis Pré-Selecionadas
<br><br>

| Variável | Descrição |
| :--- | :--- |
| `PropBaixaRenda` | Variável resposta binária (0 ou 1), derivada da "Proporção de pessoas com renda menor de ¼ do salário mínimo". |
| `TxAnalfa` | Taxa de analfabetismo do município (%) |
| `TxDesemp` | Taxa de desemprego do município (%) |
| `PopRes` | População residente do município (Contagem) |
| `Saneat` | Quantidade de moradores com abastecimento de água (Contagem) |
| `ObtOcorr` | Óbitos ocorridos no município |

# Preparação dos Dados
<br><br>

## Leitura
```{r setup, message=FALSE, warning=FALSE, include=FALSE}
libs <- c("ggplot2",
          "dplyr",
          "tidyverse",
          "magrittr",
          "stringr",
          "ggeffects",
          "gridExtra",
          "car",
          "hnp",
          "plotly",
          "rgl",
          "magick",
          "viridis")

for (lib in libs){
  
  if(!require(lib, character.only = TRUE)) install.packages(lib, repos = "https://cran-r.c3sl.ufpr.br/")
  
  library(lib, character.only = TRUE)
}

```

```{r leitura, message=FALSE, warning=FALSE}
url <- "https://gist.githubusercontent.com/jonhsp/5cf24aa66c3fb173fea117bf4cb1dbc7/raw/29b6a4bcb197ab9be16663f8c73edcfd6b3c51f3/MunicipiosRS.xlsx%2520-%2520Quartis_1_e_3.csv"
df <- read_csv(url)

```

```{r tratamentos, message=FALSE, warning=FALSE}

df %<>%
  select(-'Prop<025SM') %>%
  # Isolando o nome do municipio (remove codigo e espaco inicial)
  mutate(MUNICIPIO = str_remove(MUNICIPIO, "^\\d+\\s")) %>%
  mutate(MUNICIPIO = str_to_lower(MUNICIPIO)) %>%
  # Tratando hifen como zero e convertendo para numerico
  mutate(across(
    .cols = c(TxAnalfa, TxDesemp, PopRes, ObtOcorr, Saneat),
    .fns = ~ {
      .x %>%
        str_replace("^-$", "0") %>%
        str_replace_all("\\.", "") %>%
        str_replace_all(",", ".") %>%
        as.numeric()
    }
  )) %>%
  # Criando a variável binária como fator
  mutate(y_bin = factor(PropBaixaRenda, 
                        levels = c(0, 1), 
                        labels = c("Baixa Proporção", "Alta Proporção"))) %>%
  # Renomeando as colunas para minúsculo
  rename_all(str_to_lower) %>%
  # Selecionando variaveis
  select(municipio, y_bin, txanalfa, txdesemp, popres, obtocorr, saneat) 

summary(df)
```
<br><br>

# Distribuição das Variáveis
```{r distribuicao, message=FALSE, warning=FALSE, fig.align='center'}
df %>%
  # Seleciona apenas colunas numéricas
  select(where(is.numeric)) %>%
  # Pivota os dados para o formato longo (ideal para facet_wrap)
  pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor") %>%
  
  ggplot(aes(x = Valor)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_density(color = "red", size = 1) +
  # Cria um mini-gráfico para cada variável
  facet_wrap(~ Variavel, scales = "free") +
  labs(
    title = "Distribuição das Variáveis Preditoras",
    x = "Valor da Variável",
    y = "Densidade"
  ) +
  theme_light()
```
<br><br>

# Transformações
```{r transformacoes, message=FALSE, warning=FALSE}
df_transf <- df %>%
        # Remove municípios com população zero (evita log(0) = -Inf)
        filter(popres > 0) %>%
        # Remoção de NAs
        #drop_na() %>%
        # log populacao
        mutate(log_popres = log(popres)) %>% 
        # Obtos por 100.000 habitantes
        mutate(obt_100k = obtocorr / popres * 100000) %>%
        # Saneamento por 100.000 habitantes
        mutate(saneat_100k = saneat / popres * 100000) %>%
        # Remoção das variáveis originais
        select(-c(popres, obtocorr, saneat))
        
```
<br><br>

# Distribuição das Variáveis Transformadas

## Visualização individual
```{r distribuicao_transf, message=FALSE, warning=FALSE, fig.align='center'}
df_transf %>%
  # Seleciona apenas colunas numéricas
  select(where(is.numeric)) %>%
  # Pivota os dados para o formato longo (ideal para facet_wrap)
  pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor") %>%
  
  ggplot(aes(x = Valor)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_density(color = "red", size = 1) +
  # Cria um mini-gráfico para cada variável
  facet_wrap(~ Variavel, scales = "free") +
  labs(
    title = "Distribuição das Variáveis Transformadas",
    x = "Valor da Variável",
    y = "Densidade"
  ) +
  theme_light()
```
<br><br>

## Visualização por grupo (Baixa vs Alta Proporção)
```{r distribuicao_transf_por_grupo, message=FALSE, warning=FALSE, fig.align='center'}
# Visualização das variáveis numéricas por nível da variável resposta

df_transf %>%
  # 1. Seleciona numéricas E a variável resposta (y_bin)
  select(y_bin, where(is.numeric)) %>%
  
  # 2. Pivota apenas as numéricas, mantendo o y_bin fixo (cols = -y_bin)
  pivot_longer(cols = -y_bin, names_to = "Variavel", values_to = "Valor") %>%
  
  # 3. Adiciona 'fill = y_bin' para separar as cores por grupo
  ggplot(aes(x = Valor, fill = y_bin, color = y_bin)) +
  
  # position = "identity" permite que os histogramas se sobreponham (transparencia ajuda)
  geom_histogram(aes(y = ..density..), bins = 20, alpha = 0.4, position = "identity") +
  
  # Linha de densidade também separada por cor
  geom_density(alpha = 0.2, size = 1) +
  
  facet_wrap(~ Variavel, scales = "free") +
  
  labs(
    title = "Distribuição das Variáveis por Grupo (Baixa vs Alta Proporção)",
    x = "Valor da Variável",
    y = "Densidade",
    fill = "Grupo",
    color = "Grupo"
  ) +
  theme_light() +
  # Move a legenda para baixo para dar mais espaço aos gráficos
  theme(legend.position = "bottom")


```
<br><br>

```{r distribuicao_transf_por_grupo_boxplot, message=FALSE, warning=FALSE, fig.align='center'}
# Visualização das variáveis numéricas por nível da variável resposta (Boxplot)

df_transf %>%
  # 1. Seleciona numéricas E a variável resposta (y_bin)
  select(y_bin, where(is.numeric)) %>%
  
  # 2. Pivota apenas as numéricas, mantendo o y_bin fixo
  pivot_longer(cols = -y_bin, names_to = "Variavel", values_to = "Valor") %>%
  
  # 3. MUDANÇA: Eixo X é o Grupo (y_bin), Eixo Y é o Valor numérico
  ggplot(aes(x = y_bin, y = Valor, fill = y_bin)) +
  
  # Geometria de Boxplot
  geom_boxplot(alpha = 0.7, outlier.colour = "red", outlier.shape = 1) +
  
  # Escalas livres no eixo Y para acomodar magnitudes diferentes
  facet_wrap(~ Variavel, scales = "free_y") +
  
  labs(
    title = "Boxplots das Variáveis por Grupo",
    x = "Grupo",
    y = "Valor da Variável",
    fill = "Grupo"
  ) +
  theme_light() +
  theme(legend.position = "bottom")
```
<br><br>

## Relação entre Analfabetismo e Desemprego
```{r relacao_txanalfa_txdesemp, message=FALSE, warning=FALSE, fig.align='center'}
# Gráfico de Dispersão: Analfabetismo vs Desemprego por Grupo

df_transf %>%
  ggplot(aes(x = txanalfa, y = txdesemp, color = y_bin)) +
  
  # Adiciona os pontos (dispersão)
  geom_point(alpha = 0.6, size = 2) +
  
  labs(
    title = "Relação entre Analfabetismo e Desemprego",
    subtitle = "Segmentado pela Proporção de Baixa Renda (Y)",
    x = "Taxa de Analfabetismo (%)",
    y = "Taxa de Desemprego (%)",
    color = "Situação (Y)"
  ) +
  
  theme_light() +
  theme(legend.position = "bottom")
```
<br><br>

# Ajustes de Modelos

Estamos construindo os modelos progressivamente. O objetivo é encontrar o equilíbrio entre simplicidade e capacidade explicativa.

## Modelo Nulo
O modelo nulo consiste na estimação apenas do $\beta_{0}$ (intercepto), sem incluir os efeitos das variáveis preditoras. Este modelo será ajustado apenas para comparação da deviance residual.

```{r mod_nulo, message=FALSE, warning=FALSE}

ajuste_nulo <- glm(y_bin ~ 1, data = df_transf, family = binomial(link = "logit"))

summary(ajuste_nulo)
```

## Modelo 1 - Todas as variáveis 

Este é o modelo base (saturado), assumindo que todas as relações são lineares.

```{r mod1, message=FALSE, warning=FALSE}
# Ajuste do modelo apenas com efeitos principais lineares
ajuste_1 <- glm(y_bin ~ txanalfa + txdesemp + log_popres + saneat_100k + obt_100k, 
                data = df_transf, 
                family = binomial(link = "logit"))

# Sumário para ver coeficientes e significância individual
summary(ajuste_1)

# Análise de Deviance (ANOVA) para ver a contribuição de cada variável ao ser adicionada
# O teste "Chisq" é o adequado para GLMs binomiais
anova(ajuste_1, test = "Chisq")
```

### Diagnóstico do Modelo 1

A análise do modelo inicial (apenas efeitos principais lineares) revela os seguintes pontos:

1.  **Qualidade do Ajuste:**
    * **AIC:** 101.62 (Base de comparação).
    * **Deviance Residual:** Reduziu de 343.80 (Nulo) para 89.62, indicando que o conjunto de variáveis explica uma grande parcela da variabilidade dos dados.

2.  **Significância dos Preditores:**
    * **`txanalfa` (Analfabetismo):** Altamente significativa ($p < 0.001$). O coeficiente positivo ($1.31$) confirma que quanto maior o analfabetismo, maior a chance de o município pertencer ao grupo de alta pobreza.
    * **`txdesemp` (Desemprego):** Significativa ($p = 0.003$). Coeficiente positivo ($0.73$), indicando que o desemprego também impulsiona a pobreza.
    * **`log_popres` (População):** Não significativa ($p = 0.45$). Isso sugere que, em uma relação puramente linear, o tamanho do município não distingue bem os grupos de renda. Isso reforça a necessidade de testar termos quadráticos.
    * **`saneat_100k` e `obt_100k`:** Não apresentaram significância estatística neste modelo ($p > 0.05$).

**Conclusão:** O modelo captura bem os efeitos de educação e trabalho, mas falha em capturar a influência da demografia (população) e infraestrutura (saneamento) em sua forma linear.

## Modelo 2 - Termos Quadráticos (Não-Linearidade)

Com base na análise exploratória, adicionamos termos quadráticos para **População** e **Desemprego**, mantendo as demais variáveis lineares. O objetivo é testar se a relação com a pobreza é curvilínea.

```{r mod2, message=FALSE, warning=FALSE}
# Ajuste do modelo com polinômios de 2º grau para as variáveis identificadas
ajuste_2 <- glm(y_bin ~ txanalfa + saneat_100k + obt_100k +
                poly(txdesemp, 2) + 
                poly(log_popres, 2),
                data = df_transf, 
                family = binomial(link = "logit"))

# Sumário para verificar a significância dos termos quadráticos
summary(ajuste_2)

# Teste de Deviance (ANOVA) para comparar se o Modelo 2 é superior ao Modelo 1
# H0: Os modelos são iguais (a complexidade extra não ajuda)
# H1: O Modelo 2 é melhor
anova(ajuste_nulo, ajuste_1, ajuste_2, test = "Chisq")
```

### Diagnóstico do Modelo 2 (Termos Quadráticos)

Os resultados obtidos a partir do ajuste do modelo com termos quadráticos indicam uma superioridade clara sobre o modelo linear simples (Modelo 1). A análise detalhada segue abaixo:

1.  **Qualidade do Ajuste:**
    * **AIC:** 96.534 (Base de comparação).
    * **Deviance Residual:** Reduziu de 89.62 para 80.534, indicando que a inclusão da não linearidade na relação das variáveis preditoras ajuda a explicar melhor os dados, mesmo sendo penalizado pela complexidade adicional dos termos quadráticos..

2.  **Teste de Razão de Verossimilhança (ANOVA):**
    A comparação formal entre os modelos resultou em um **p-valor de 0.0106** (Chi-quadrado). Como $p < 0.05$, rejeitamos a hipótese nula de que os modelos são equivalentes. Isso prova estatisticamente que a inclusão da curvatura para Desemprego e População adicionou poder explicativo real ao modelo, e não apenas ruído.

3.  **Análise dos Coeficientes:**
    * **Não-Linearidade Confirmada:** Os termos quadráticos para Desemprego (`poly(txdesemp, 2)2`, p=0.027) e População (`poly(log_popres, 2)2`, p=0.027) foram estatisticamente significativos. Isso sugere que a relação dessas variáveis com a pobreza não é constante, variando conforme a magnitude dos indicadores (formato de curva).
    * **Preditores Fortes:** A Taxa de Analfabetismo (`txanalfa`) permanece como o preditor mais robusto do modelo ($p < 0.001$), mantendo seu efeito positivo forte.
    * **Variáveis Redundantes:** A variável de Saneamento (`saneat_100k`) apresentou p-valor alto (0.73), sugerindo que, na presença das outras variáveis (especialmente Analfabetismo), ela não adiciona informação nova relevante para a classificação.
    * **Óbitos:** Curiosamente, a taxa de óbitos (`obt_100k`) tornou-se significativa ($p=0.04$) neste modelo ajustado.

**Conclusão:** O Modelo 2 será adotado como base para a seleção final. O próximo passo será refinar este modelo aplicando o método *Stepwise* para remover automaticamente os preditores não significativos (como o Saneamento) e obter o modelo final parcimonioso.

# Seleção do Modelo Final e Diagnóstico

Nesta etapa, refinamos o modelo quadrático removendo variáveis redundantes pelo critério de Akaike (AIC) e realizamos os diagnósticos de qualidade do ajuste.

## Seleção de Variáveis (Stepwise)

Utilizamos o método *stepwise* (direção "both") para remover preditores não significativos e chegar ao modelo mais parcimonioso possível.


```{r step, message=FALSE, warning=FALSE}
# Aplica o algoritmo Stepwise no Modelo 2 (Quadrático)
# O R testará remover/adicionar variáveis para baixar o AIC
modelo_step <- step(ajuste_2, direction = "both", trace = 1)

# Exibe o resumo do modelo vencedor
summary(modelo_step)
```

### Refinamento e Seleção Final

A análise do modelo *stepwise* indicou que a taxa de óbitos (`obt_100k`) possui significância estatística marginal ($p \approx 0.015$) e contribui para uma redução da deviance. O coeficiente estimado ($\beta \approx -0.003$) sugere um efeito negativo, indicando que municípios com maiores taxas de óbitos por causas externas tenderiam a ter menor probabilidade de alta pobreza.

Entretanto, levando em consideração a ausência de interpretação prática da redução da violência com o aumento da pobreza, esse resultado pode ser interpretado como o efeito captado de variáveis externas ao modelo. Além disso, a variação no Critério de Informação de Akaike (AIC) entre os modelos é pequena ($\Delta AIC < 4$), o que, segundo a literatura, sugere equivalência empírica entre os modelos.

Visando a **parcimônia** e a interpretabilidade, optou-se pela remoção desta variável, definindo-se o modelo final com foco nos determinantes socioeconômicos diretos (Educação e Trabalho) e na estrutura demográfica (População).

```{r modelo_final}
# Atualizando o modelo para remover a variável de óbitos (obt_100k)
modelo_final <- update(modelo_step, . ~ . - obt_100k)

# Exibindo o sumário do modelo vencedor
summary(modelo_final)
```

# Interpretação dos resultados

A partir do ajuste final, podemos formalizar a relação entre as variáveis preditoras e a probabilidade de um município apresentar alta proporção de baixa renda.
<br><br>

## Especificação da Equação Estimada

Abaixo, apresentamos a equação do preditor linear ($\eta$) com os coeficientes estimados substituídos. Esta equação descreve o **logaritmo da chance** (*log-odds*):

$$
\begin{aligned}
\ln \left( \frac{\hat{p}}{1 - \hat{p}} \right) = & `r round(coef(modelo_final)[1], 3)` \\
& + `r round(coef(modelo_final)[2], 3)` \cdot \text{Analfa} \\
& + `r round(coef(modelo_final)[3], 3)` \cdot \text{Desemp}^1 + `r round(coef(modelo_final)[4], 3)` \cdot \text{Desemp}^2 \\
& + `r round(coef(modelo_final)[5], 3)` \cdot \text{log(Pop)}^1 `r round(coef(modelo_final)[6], 3)` \cdot \text{log(Pop)}^2
\end{aligned}
$$
<small>*Nota: Os termos com sobrescritos 1 e 2 referem-se aos componentes linear e quadrático dos polinômios ortogonais.*</small>

## Análise dos Efeitos

1.  **Taxa de Analfabetismo:**
    * Apresenta uma relação linear positiva ($\hat{\beta} \approx `r round(coef(modelo_final)[2], 2)`$).
    * **Interpretação:** É o indicador mais consistente. O aumento na taxa de analfabetismo eleva diretamente a chance de o município pertencer ao grupo de alta pobreza.

2.  **Taxa de Desemprego (Não-Linearidade):**
    * A significância dos termos linear e quadrático confirma que o impacto do desemprego não é constante.
    * **Interpretação:** A relação sugere um comportamento de aceleração (curva em "J"). Em níveis baixos de desemprego, o impacto na pobreza é moderado, mas à medida que a taxa cresce, a probabilidade de alta pobreza aumenta de forma mais acentuada.

3.  **Tamanho da População (Escala):**
    * O termo quadrático negativo ($\hat{\beta} \approx `r round(coef(modelo_final)[6], 2)`$) indica uma curva côncava ("U" invertido).
    * **Interpretação:** Isso sugere que a dinâmica da pobreza muda conforme a escala do município, onde municípios de porte médio podem apresentar riscos distintos comparados a pequenos municípios ou grandes centros urbanos, capturando efeitos de aglomeração ou estrutura social.

## Razão de Chances (Odds Ratios)

Para quantificar a magnitude desses efeitos, apresentamos as estimativas na escala da Razão de Chances (OR).

```{r or, message=FALSE, warning=FALSE}
# Extração dos coeficientes e cálculo do OR (exp(beta))
tabela_or <- exp(cbind(OR = coef(modelo_final), confint(modelo_final)))

# Exibição formatada
knitr::kable(tabela_or, digits = 3, caption = "Razão de Chances (Odds Ratios) e IC 95%")
```
<br><br>



# Visualizações

<br><br>

## Visualização ( Variáveis fixadas na média)

```{r visualizacao_modelo_final_media, message=FALSE, warning=FALSE, fig.width=15, fig.height=6, fig.align='center'}

# 1. Efeito do Analfabetismo (Linear)
# Mostra a probabilidade predita de Alta Pobreza conforme a Taxa de Analfabetismo aumenta
plot_analfa <- ggpredict(modelo_final, terms = "txanalfa") %>%
  plot() +
  labs(
    title = "Efeito do Analfabetismo",
    x = "Taxa de Analfabetismo (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 2. Efeito do Desemprego (Quadrático)
# Mostra a curva não-linear capturada pelo polinômio
plot_desemp <- ggpredict(modelo_final, terms = "txdesemp [all]") %>%
  plot() +
  labs(
    title = "Efeito do Desemprego (Não-linear)",
    x = "Taxa de Desemprego (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 3. Efeito da População (Quadrático)
# Plota a curvatura ajustada para o Log da População
plot_pop <- ggpredict(modelo_final, terms = "log_popres [all]") %>%
  plot() +
  labs(
    title = "Efeito do Tamanho da População",
    x = "Log(População)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# Exibir os gráficos juntos usando gridExtra
# Organiza em 2 colunas: Analfabetismo e Desemprego na linha 1, População centralizada na linha 2
grid.arrange(plot_analfa, plot_desemp, plot_pop, ncol = 3)



```
<br><br>

## Visualização ( Variáveis fixadas na moda)

```{r visualizacao_modelo_final_moda, message=FALSE, warning=FALSE,fig.width=15, fig.height=6, fig.align='center'}

# 1. Efeito do Analfabetismo (Linear)
# Mostra a probabilidade predita de Alta Pobreza conforme a Taxa de Analfabetismo aumenta
plot_analfa <- ggpredict(modelo_final, terms = "txanalfa", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Analfabetismo",
    x = "Taxa de Analfabetismo (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 2. Efeito do Desemprego (Quadrático)
# Mostra a curva não-linear capturada pelo polinômio
plot_desemp <- ggpredict(modelo_final, terms = "txdesemp [all]", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Desemprego (Não-linear)",
    x = "Taxa de Desemprego (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 3. Efeito da População (Quadrático)
# Plota a curvatura ajustada para o Log da População
plot_pop <- ggpredict(modelo_final, terms = "log_popres [all]", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Tamanho da População",
    x = "Log(População)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# Exibir os gráficos juntos usando gridExtra
# Organiza em 2 colunas: Analfabetismo e Desemprego na linha 1, População centralizada na linha 2
grid.arrange(plot_analfa, plot_desemp, plot_pop, ncol = 3)



```
<br><br>

## Visualização 3D das Probabilidades


A animação abaixo apresenta o espaço tridimensional das variáveis preditoras, onde a cor dos pontos indica a probabilidade estimada de alta pobreza.

```{r visualizacao_3d_gif, message=FALSE, warning=FALSE, eval=FALSE,cache=TRUE}


# 1. PREPARAÇÃO
# Limpa dispositivo gráfico
while (rgl.cur() > 0) { rgl.close() }

# Cores baseadas na probabilidade
probs <- predict(modelo_final, type = "response")
paleta <- viridis(100, option = "D") 
indices_cor <- cut(probs, breaks = 100, labels = FALSE)
cores_probs <- paleta[indices_cor]

# 2. RENDERIZAÇÃO
open3d(windowRect = c(0, 0, 800, 800))

# Adiciona APENAS os Pontos
plot3d(x = df_transf$txanalfa, 
       y = df_transf$txdesemp, 
       z = df_transf$log_popres, 
       col = cores_probs, 
       type = "s", 
       radius = 0.18,
       xlab = "", ylab = "", zlab = "", 
       box = FALSE)

# Adiciona Eixos e Caixa (Correção do erro de renderização)
decorate3d(
  xlab = "Analfabetismo", 
  ylab = "Desemprego", 
  zlab = "Log(Populacao)", # Sem acento
  box = TRUE, 
  axes = TRUE,
  aspect = TRUE
)

# 3. GERAR GIF
movie3d(spin3d(axis = c(0, 0, 1), rpm = 7), 
        duration = 6, 
        dir = "baixa_renda_files\\figure_animeted", 
        movie = "visualizacao_probabilidades_3d", 
        type = "gif", 
        clean = TRUE)

legend3d("topright", 
         legend = c("Muito Alta (>80%)", "Alta (60%)", "Média (40%)", "Baixa (20%)", "Muito Baixa (<10%)"), 
         pch = 16,           # Símbolo (Bolinha preenchida)
         col = c(paleta[90], paleta[70], paleta[50], paleta[30], paleta[10]), # Cores correspondentes
         cex = 1.0,          # Tamanho do texto
         inset = c(0.02)     # Margem em relação à borda
)

close3d()

```

```{r exibir_gif_prob, echo=FALSE, fig.align='center', out.width='800px'}
# Este chunk serve apenas para incorporar o GIF no HTML final de forma segura
knitr::include_graphics("baixa_renda_files\\figure_animeted\\visualizacao_probabilidades_3d.gif")
```
<br><br>

## Visualização 3D de Acertos e Erros

Nesta animação, os pontos são coloridos conforme o desempenho do modelo. Pontos **Azuis** indicam classificações corretas, enquanto pontos **Vermelhos** indicam onde o modelo errou.

```{r visualizacao_erros_gif, message=FALSE, warning=FALSE, eval=FALSE, cache=TRUE}

# 1. PREPARAÇÃO
# Define o caminho exato que você usou
output_dir <- "baixa_renda_files/figure_animeted"
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

# Limpa dispositivo gráfico
while (rgl.cur() > 0) { rgl.close() }

# Preparar dados de Classificação
df_class <- df_transf %>%
  mutate(
    prob = predict(modelo_final, type = "response"),
    classe_pred = ifelse(prob > 0.5, "Alta Proporção", "Baixa Proporção"),
    y_bin_char = as.character(y_bin),
    resultado = ifelse(y_bin_char == classe_pred, "Acerto", "Erro")
  )

# Definir Cores: Azul para Acerto, Vermelho para Erro
cores_resultado <- ifelse(df_class$resultado == "Acerto", "#1f77b4", "#d62728")

# 2. RENDERIZAÇÃO
open3d(windowRect = c(0, 0, 800, 800))

# Plotar pontos (Mesmo radius e logica do anterior)
plot3d(x = df_class$txanalfa, 
       y = df_class$txdesemp, 
       z = df_class$log_popres, 
       col = cores_resultado, 
       type = "s", 
       radius = 0.18,
       xlab = "", ylab = "", zlab = "", 
       box = FALSE)

# Adicionar Eixos e Caixa
decorate3d(
  xlab = "Analfabetismo", 
  ylab = "Desemprego", 
  zlab = "Log(Populacao)", 
  box = TRUE, 
  axes = TRUE, 
  aspect = TRUE
)

# Adicionar Legenda (ANTES de gravar o filme para aparecer no GIF)
legend3d("topright", 
         legend = c("Acerto", "Erro"), 
         pch = 16, 
         col = c("#1f77b4", "#d62728"), 
         cex = 1.0, 
         inset = c(0.02))

# 3. GERAR GIF
movie3d(spin3d(axis = c(0, 0, 1), rpm = 7), 
        duration = 6, 
        dir = output_dir, 
        movie = "visualizacao_erros_3d", 
        type = "gif", 
        clean = TRUE)

close3d()

```

```{r exibir_gif_erros, echo=FALSE, fig.align='center', out.width='800px'}
# Este chunk serve apenas para incorporar o GIF no HTML final de forma segura
knitr::include_graphics("baixa_renda_files\\figure_animeted\\visualizacao_erros_3d.gif")
```
<br><br>

## Visualização da probabilidade conjunta 

```{r visualizacao_probabilidade_conjunta, message=FALSE, warning=FALSE, fig.width=15, fig.height=6, fig.align='center'}
# Definindo as medianas para fixar as variáveis de controle
med_analfa <- median(df_transf$txanalfa)
med_desemp <- median(df_transf$txdesemp)
med_pop    <- median(df_transf$log_popres)

# ----------------------------------------------------------------------------
# GRÁFICO 1: Analfabetismo vs Desemprego (Fixando População)
# ----------------------------------------------------------------------------
grid1 <- expand.grid(
  txanalfa = seq(min(df_transf$txanalfa), max(df_transf$txanalfa), length.out = 50),
  txdesemp = seq(min(df_transf$txdesemp), max(df_transf$txdesemp), length.out = 50),
  log_popres = med_pop
)
grid1$prob <- predict(modelo_final, newdata = grid1, type = "response")

p1 <- ggplot(grid1, aes(x = txanalfa, y = txdesemp)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) + # Pontos reais
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1)) +
  scale_color_manual(values = c("black", "darkred")) +
  labs(title = "Analfabetismo vs Desemprego", subtitle = "População fixa na mediana") +
  theme_minimal() + theme(legend.position = "none")

# ----------------------------------------------------------------------------
# GRÁFICO 2: Analfabetismo vs Log(População) (Fixando Desemprego)
# ----------------------------------------------------------------------------
grid2 <- expand.grid(
  txanalfa = seq(min(df_transf$txanalfa), max(df_transf$txanalfa), length.out = 50),
  log_popres = seq(min(df_transf$log_popres), max(df_transf$log_popres), length.out = 50),
  txdesemp = med_desemp
)
grid2$prob <- predict(modelo_final, newdata = grid2, type = "response")

p2 <- ggplot(grid2, aes(x = txanalfa, y = log_popres)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) +
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1)) +
  scale_color_manual(values = c("black", "darkred")) +
  labs(title = "Analfabetismo vs População", subtitle = "Desemprego fixo na mediana") +
  theme_minimal() + theme(legend.position = "none")

# ----------------------------------------------------------------------------
# GRÁFICO 3: Desemprego vs Log(População) (Fixando Analfabetismo)
# ----------------------------------------------------------------------------
grid3 <- expand.grid(
  txdesemp = seq(min(df_transf$txdesemp), max(df_transf$txdesemp), length.out = 50),
  log_popres = seq(min(df_transf$log_popres), max(df_transf$log_popres), length.out = 50),
  txanalfa = med_analfa
)
grid3$prob <- predict(modelo_final, newdata = grid3, type = "response")

p3 <- ggplot(grid3, aes(x = txdesemp, y = log_popres)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) +
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1), name="Prob.\nPredita") +
  scale_color_manual(values = c("black", "darkred"), name="Real") +
  labs(title = "Desemprego vs População", subtitle = "Analfabetismo fixo na mediana") +
  theme_minimal() + theme(legend.position = "right")

# ----------------------------------------------------------------------------
# Exibição Conjunta
# ----------------------------------------------------------------------------
# Organiza os 3 plots. O p3 fornece a legenda para todos.
grid.arrange(p1, p2, p3, ncol = 3)
```
<br><br>

# Diagnóstico do Ajuste

<br><br>

## Multicolinearidade (VIF)

```{r multicolinearidade, message=FALSE, warning=FALSE}
car::vif(modelo_final)
```
Os GVIF reescalado permaneceram abaixo de 1.2 para todas as variáveis preditoras. Isso confirma a ausência de multicolinearidade prejudicial, indicando que os termos polinomiais e as taxas socioeconômicas trazem informações independentes para o modelo.


##  Resíduos e Distância de Cook

```{r residuos, message=FALSE, warning=FALSE, fig.align='center', fig.width=15, fig.height=8}

# Configura a tela para 4 gráficos (2x2)
par(mfrow = c(2, 2))

# hnp
hnp(modelo_final, resid.type = "deviance", how.many.out = TRUE, paint.out = TRUE,
    main = "Envelope Simulado", xlab = "Percentil Teórico", ylab = "Resíduos Deviance")

# Distância de Cook
plot(cooks.distance(modelo_final), type = "h",
     main = "Distância de Cook",
     ylab = "Distância de Cook",
     ylim = c(0,0.6))
abline(h = 0.5, lty = 2, col = "red")

# Residuos deviance
plot(residuals(modelo_final, type = "deviance"),
      main = "Resíduos Deviance",
      ylab = "Resíduos Deviance",
      ylim = c(-4, 4))
abline(h = c(-2, 2), lty = 2, col = "red")

# Residuos pearson
plot(residuals(modelo_final, type = "pearson"),
      main = "Resíduos Pearson",
      ylab = "Resíduos Pearson",
      ylim = c(-4, 4))
abline(h = c(-2, 2), lty = 2, col = "red")

# Retorna a configuração da tela para o padrão (1 gráfico por vez)
par(mfrow = c(1, 1))
```
- **Resíduos:** Tanto os resíduos Deviance quanto os de Pearson situam-se majoritariamente dentro do intervalo de confiança aceitável de $[-2, +2]$. Observam-se poucos pontos excedendo esse limite, e nenhum ultrapassando o valor crítico de $\pm 3$, o que indica ausência de outliers severos de ajuste.
- **Envelope Simulado:** O gráfico Half-Normal Plot confirma a adequação do componente aleatório. A totalidade dos pontos permanece dentro das bandas de envelope de 95%, validando a escolha da distribuição Binomial.
- **Influência:** A análise da Distância de Cook aponta que todos os valores permanecem muito abaixo de $0.5$, indicando que nenhum município exerce, isoladamente, influência capaz de comprometer a estabilidade dos coeficientes do modelo.

