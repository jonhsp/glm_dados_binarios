---
title: "Trabalho 1: Regressão Logística - Proporção de Baixa Renda (RS)"
subtitle: "CE314 - Modelos Lineares Generalizados (Grupo 4)"
author: "jonathas Pereira,......"
output: 
  html_document:
    theme: journal
    number_sections: true
    code_folding: 'hide'
---
___ 


# Variáveis Pré-Selecionadas
<br><br>

| Variável | Descrição |
| :--- | :--- |
| `PropBaixaRenda` | Variável resposta binária (0 ou 1), derivada da "Proporção de pessoas com renda menor de ¼ do salário mínimo". |
| `TxAnalfa` | Taxa de analfabetismo do município (%) |
| `TxDesemp` | Taxa de desemprego do município (%) |
| `PopRes` | População residente do município (Contagem) |
| `Saneat` | Quantidade de moradores com abastecimento de água (Contagem) |
| `ObtOcorr` | Óbitos ocorridos no município |

# Preparação dos Dados
<br><br>

## Leitura
```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(magrittr)
library(stringr)
library(ggeffects)
library(gridExtra)
library(car)
library(hnp)
library(plotly)
```

```{r leitura, message=FALSE, warning=FALSE}
url <- "https://gist.githubusercontent.com/jonhsp/5cf24aa66c3fb173fea117bf4cb1dbc7/raw/29b6a4bcb197ab9be16663f8c73edcfd6b3c51f3/MunicipiosRS.xlsx%2520-%2520Quartis_1_e_3.csv"
df <- read_csv(url)

```

```{r tratamentos, message=FALSE, warning=FALSE}

df %<>%
  select(-'Prop<025SM') %>%
  # Isolando o nome do municipio (remove codigo e espaco inicial)
  mutate(MUNICIPIO = str_remove(MUNICIPIO, "^\\d+\\s")) %>%
  mutate(MUNICIPIO = str_to_lower(MUNICIPIO)) %>%
  # Tratando hifen como zero e convertendo para numerico
  mutate(across(
    .cols = c(TxAnalfa, TxDesemp, PopRes, ObtOcorr, Saneat),
    .fns = ~ {
      .x %>%
        str_replace("^-$", "0") %>%
        str_replace_all("\\.", "") %>%
        str_replace_all(",", ".") %>%
        as.numeric()
    }
  )) %>%
  # Criando a variável binária como fator
  mutate(y_bin = factor(PropBaixaRenda, 
                        levels = c(0, 1), 
                        labels = c("Baixa Proporção", "Alta Proporção"))) %>%
  # Renomeando as colunas para minúsculo
  rename_all(str_to_lower) %>%
  # Selecionando variaveis
  select(municipio, y_bin, txanalfa, txdesemp, popres, obtocorr, saneat) 

summary(df)
```
<br><br>

# Distribuição das Variáveis
```{r distribuicao, message=FALSE, warning=FALSE}
df %>%
  # Seleciona apenas colunas numéricas
  select(where(is.numeric)) %>%
  # Pivota os dados para o formato longo (ideal para facet_wrap)
  pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor") %>%
  
  ggplot(aes(x = Valor)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_density(color = "red", size = 1) +
  # Cria um mini-gráfico para cada variável
  facet_wrap(~ Variavel, scales = "free") +
  labs(
    title = "Distribuição das Variáveis Preditoras",
    x = "Valor da Variável",
    y = "Densidade"
  ) +
  theme_light()
```
<br><br>

# Transformações
```{r transformacoes, message=FALSE, warning=FALSE}
df_transf <- df %>%
        # Remove municípios com população zero (evita log(0) = -Inf)
        filter(popres > 0) %>%
        # Remoção de NAs
        #drop_na() %>%
        # log populacao
        mutate(log_popres = log(popres)) %>% 
        # Obtos por 100.000 habitantes
        mutate(obt_100k = obtocorr / popres * 100000) %>%
        # Saneamento por 100.000 habitantes
        mutate(saneat_100k = saneat / popres * 100000) %>%
        # Remoção das variáveis originais
        select(-c(popres, obtocorr, saneat))
        
```
<br><br>

# Distribuição das Variáveis Transformadas

## Visualização individual
```{r distribuicao_transf, message=FALSE, warning=FALSE}
df_transf %>%
  # Seleciona apenas colunas numéricas
  select(where(is.numeric)) %>%
  # Pivota os dados para o formato longo (ideal para facet_wrap)
  pivot_longer(cols = everything(), names_to = "Variavel", values_to = "Valor") %>%
  
  ggplot(aes(x = Valor)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_density(color = "red", size = 1) +
  # Cria um mini-gráfico para cada variável
  facet_wrap(~ Variavel, scales = "free") +
  labs(
    title = "Distribuição das Variáveis Transformadas",
    x = "Valor da Variável",
    y = "Densidade"
  ) +
  theme_light()
```
<br><br>

## Visualização por grupo (Baixa vs Alta Proporção)
```{r distribuicao_transf_por_grupo, message=FALSE, warning=FALSE}
# Visualização das variáveis numéricas por nível da variável resposta

df_transf %>%
  # 1. Seleciona numéricas E a variável resposta (y_bin)
  select(y_bin, where(is.numeric)) %>%
  
  # 2. Pivota apenas as numéricas, mantendo o y_bin fixo (cols = -y_bin)
  pivot_longer(cols = -y_bin, names_to = "Variavel", values_to = "Valor") %>%
  
  # 3. Adiciona 'fill = y_bin' para separar as cores por grupo
  ggplot(aes(x = Valor, fill = y_bin, color = y_bin)) +
  
  # position = "identity" permite que os histogramas se sobreponham (transparencia ajuda)
  geom_histogram(aes(y = ..density..), bins = 20, alpha = 0.4, position = "identity") +
  
  # Linha de densidade também separada por cor
  geom_density(alpha = 0.2, size = 1) +
  
  facet_wrap(~ Variavel, scales = "free") +
  
  labs(
    title = "Distribuição das Variáveis por Grupo (Baixa vs Alta Proporção)",
    x = "Valor da Variável",
    y = "Densidade",
    fill = "Grupo",
    color = "Grupo"
  ) +
  theme_light() +
  # Move a legenda para baixo para dar mais espaço aos gráficos
  theme(legend.position = "bottom")


```
<br><br>

```{r distribuicao_transf_por_grupo_boxplot, message=FALSE, warning=FALSE}
# Visualização das variáveis numéricas por nível da variável resposta (Boxplot)

df_transf %>%
  # 1. Seleciona numéricas E a variável resposta (y_bin)
  select(y_bin, where(is.numeric)) %>%
  
  # 2. Pivota apenas as numéricas, mantendo o y_bin fixo
  pivot_longer(cols = -y_bin, names_to = "Variavel", values_to = "Valor") %>%
  
  # 3. MUDANÇA: Eixo X é o Grupo (y_bin), Eixo Y é o Valor numérico
  ggplot(aes(x = y_bin, y = Valor, fill = y_bin)) +
  
  # Geometria de Boxplot
  geom_boxplot(alpha = 0.7, outlier.colour = "red", outlier.shape = 1) +
  
  # Escalas livres no eixo Y para acomodar magnitudes diferentes
  facet_wrap(~ Variavel, scales = "free_y") +
  
  labs(
    title = "Boxplots das Variáveis por Grupo",
    x = "Grupo",
    y = "Valor da Variável",
    fill = "Grupo"
  ) +
  theme_light() +
  theme(legend.position = "bottom")
```
<br><br>

## Relação entre Analfabetismo e Desemprego
```{r relacao_txanalfa_txdesemp, message=FALSE, warning=FALSE}
# Gráfico de Dispersão: Analfabetismo vs Desemprego por Grupo

df_transf %>%
  ggplot(aes(x = txanalfa, y = txdesemp, color = y_bin)) +
  
  # Adiciona os pontos (dispersão)
  geom_point(alpha = 0.6, size = 2) +
  
  labs(
    title = "Relação entre Analfabetismo e Desemprego",
    subtitle = "Segmentado pela Proporção de Baixa Renda (Y)",
    x = "Taxa de Analfabetismo (%)",
    y = "Taxa de Desemprego (%)",
    color = "Situação (Y)"
  ) +
  
  theme_light() +
  theme(legend.position = "bottom")
```
<br><br>

# Ajustes de Modelos

Estamos construindo os modelos progressivamente. O objetivo é encontrar o equilíbrio entre simplicidade e capacidade explicativa.

## Modelo 1 - Todas as variáveis 

Este é o modelo base (saturado), assumindo que todas as relações são lineares.

```{r mod1, message=FALSE, warning=FALSE}
# Ajuste do modelo apenas com efeitos principais lineares
ajuste_1 <- glm(y_bin ~ txanalfa + txdesemp + log_popres + saneat_100k + obt_100k, 
                data = df_transf, 
                family = binomial(link = "logit"))

# Sumário para ver coeficientes e significância individual
summary(ajuste_1)

# Análise de Deviance (ANOVA) para ver a contribuição de cada variável ao ser adicionada
# O teste "Chisq" é o adequado para GLMs binomiais
anova(ajuste_1, test = "Chisq")
```

### Diagnóstico do Modelo 1

A análise do modelo inicial (apenas efeitos principais lineares) revela os seguintes pontos:

1.  **Qualidade do Ajuste:**
    * **AIC:** 101.62 (Base de comparação).
    * **Deviance Residual:** Reduziu de 343.80 (Nulo) para 89.62, indicando que o conjunto de variáveis explica uma grande parcela da variabilidade dos dados.

2.  **Significância dos Preditores:**
    * **`txanalfa` (Analfabetismo):** Altamente significativa ($p < 0.001$). O coeficiente positivo ($1.31$) confirma que quanto maior o analfabetismo, maior a chance de o município pertencer ao grupo de alta pobreza.
    * **`txdesemp` (Desemprego):** Significativa ($p = 0.003$). Coeficiente positivo ($0.73$), indicando que o desemprego também impulsiona a pobreza.
    * **`log_popres` (População):** Não significativa ($p = 0.45$). Isso sugere que, em uma relação puramente linear, o tamanho do município não distingue bem os grupos de renda. Isso reforça a necessidade de testar termos quadráticos.
    * **`saneat_100k` e `obt_100k`:** Não apresentaram significância estatística neste modelo ($p > 0.05$).

**Conclusão:** O modelo captura bem os efeitos de educação e trabalho, mas falha em capturar a influência da demografia (população) e infraestrutura (saneamento) em sua forma linear.

## Modelo 2 - Termos Quadráticos (Não-Linearidade)

Com base na análise exploratória, adicionamos termos quadráticos para **População** e **Desemprego**, mantendo as demais variáveis lineares. O objetivo é testar se a relação com a pobreza é curvilínea.

```{r mod2, message=FALSE, warning=FALSE}
# Ajuste do modelo com polinômios de 2º grau para as variáveis identificadas
ajuste_2 <- glm(y_bin ~ txanalfa + saneat_100k + obt_100k +
                poly(txdesemp, 2) + 
                poly(log_popres, 2),
                data = df_transf, 
                family = binomial(link = "logit"))

# Sumário para verificar a significância dos termos quadráticos
summary(ajuste_2)

# Teste de Deviance (ANOVA) para comparar se o Modelo 2 é superior ao Modelo 1
# H0: Os modelos são iguais (a complexidade extra não ajuda)
# H1: O Modelo 2 é melhor
anova(ajuste_1, ajuste_2, test = "Chisq")
```

### Diagnóstico do Modelo 2 (Termos Quadráticos)

Os resultados obtidos a partir do ajuste do modelo com termos quadráticos indicam uma superioridade clara sobre o modelo linear simples (Modelo 1). A análise detalhada segue abaixo:

1.  **Teste de Razão de Verossimilhança (ANOVA):**
    A comparação formal entre os modelos resultou em um **p-valor de 0.0106** (Chi-quadrado). Como $p < 0.05$, rejeitamos a hipótese nula de que os modelos são equivalentes. Isso prova estatisticamente que a inclusão da curvatura para Desemprego e População adicionou poder explicativo real ao modelo, e não apenas ruído.

2.  **Critério de Akaike (AIC):**
    O AIC reduziu de **101.62** (Modelo 1) para **96.53** (Modelo 2). Uma queda dessa magnitude confirma que o Modelo 2 é mais eficiente: ele explica melhor os dados mesmo sendo penalizado pela complexidade adicional dos termos quadráticos.

3.  **Análise dos Coeficientes:**
    * **Não-Linearidade Confirmada:** Os termos quadráticos para Desemprego (`poly(txdesemp, 2)2`, p=0.027) e População (`poly(log_popres, 2)2`, p=0.027) foram estatisticamente significativos. Isso sugere que a relação dessas variáveis com a pobreza não é constante, variando conforme a magnitude dos indicadores (formato de curva).
    * **Preditores Fortes:** A Taxa de Analfabetismo (`txanalfa`) permanece como o preditor mais robusto do modelo ($p < 0.001$), mantendo seu efeito positivo forte.
    * **Variáveis Redundantes:** A variável de Saneamento (`saneat_100k`) apresentou p-valor alto (0.73), sugerindo que, na presença das outras variáveis (especialmente Analfabetismo), ela não adiciona informação nova relevante para a classificação.
    * **Óbitos:** Curiosamente, a taxa de óbitos (`obt_100k`) tornou-se significativa ($p=0.04$) neste modelo ajustado.

**Conclusão:** O Modelo 2 será adotado como base para a seleção final. O próximo passo será refinar este modelo aplicando o método *Stepwise* para remover automaticamente os preditores não significativos (como o Saneamento) e obter o modelo final parcimonioso.

# Seleção do Modelo Final e Diagnóstico

Nesta etapa, refinamos o modelo quadrático removendo variáveis redundantes pelo critério de Akaike (AIC) e realizamos os diagnósticos de qualidade do ajuste.

## Seleção de Variáveis (Stepwise)

Utilizamos o método *stepwise* (direção "both") para remover preditores não significativos e chegar ao modelo mais parcimonioso possível.


```{r step, message=FALSE, warning=FALSE}
# Aplica o algoritmo Stepwise no Modelo 2 (Quadrático)
# O R testará remover/adicionar variáveis para baixar o AIC
modelo_step <- step(ajuste_2, direction = "both", trace = 1)

# Exibe o resumo do modelo vencedor
summary(modelo_step)
```

O modelo capta a não linearidade de log populção, porém também acrescenta a taxa de obtos ao nível de 5% de significancia, porém a mesma não seria incluida ao nível de 1% de significancia.
Visando a simplicidade do modelo, a taxa de obtos será removida

```{r modelo_final, message=FALSE, warning=FALSE}

modelo_final <- update(modelo_step, . ~ . - obt_100k)

# Exibe o resumo do modelo vencedor
cat("----Summary do Modelo Final----")
summary(modelo_final)
cat("----Anova entre os Modelos----")
anova(modelo_final,modelo_step, ajuste_2, test = "Chisq")
```


## Interpretação dos Efeitos (Odds Ratios)
A tabela abaixo apresenta a Razão de Chances (Odds Ratios) para as variáveis do modelo final.

```{r or, message=FALSE, warning=FALSE}
# Extração dos coeficientes e cálculo do OR (exp(beta))
tabela_or <- exp(cbind(OR = coef(modelo_final), confint(modelo_final)))

# Exibição formatada
knitr::kable(tabela_or, digits = 3, caption = "Razão de Chances (Odds Ratios) e IC 95%")
```
# Visualizações

## Visualização ( Variáveis fixadas na média)

```{r visualizacao_modelo_final_media, message=FALSE, warning=FALSE}

# 1. Efeito do Analfabetismo (Linear)
# Mostra a probabilidade predita de Alta Pobreza conforme a Taxa de Analfabetismo aumenta
plot_analfa <- ggpredict(modelo_final, terms = "txanalfa") %>%
  plot() +
  labs(
    title = "Efeito do Analfabetismo",
    x = "Taxa de Analfabetismo (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 2. Efeito do Desemprego (Quadrático)
# Mostra a curva não-linear capturada pelo polinômio
plot_desemp <- ggpredict(modelo_final, terms = "txdesemp [all]") %>%
  plot() +
  labs(
    title = "Efeito do Desemprego (Não-linear)",
    x = "Taxa de Desemprego (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 3. Efeito da População (Quadrático)
# Plota a curvatura ajustada para o Log da População
plot_pop <- ggpredict(modelo_final, terms = "log_popres [all]") %>%
  plot() +
  labs(
    title = "Efeito do Tamanho da População",
    x = "Log(População)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# Exibir os gráficos juntos usando gridExtra
# Organiza em 2 colunas: Analfabetismo e Desemprego na linha 1, População centralizada na linha 2
grid.arrange(plot_analfa, plot_desemp, plot_pop, ncol = 3, 
             layout_matrix = rbind(c(1, 2), c(3, 3)))



```


## Visualização ( Variáveis fixadas na moda)

```{r visualizacao_modelo_final_moda, message=FALSE, warning=FALSE}

# 1. Efeito do Analfabetismo (Linear)
# Mostra a probabilidade predita de Alta Pobreza conforme a Taxa de Analfabetismo aumenta
plot_analfa <- ggpredict(modelo_final, terms = "txanalfa", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Analfabetismo",
    x = "Taxa de Analfabetismo (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 2. Efeito do Desemprego (Quadrático)
# Mostra a curva não-linear capturada pelo polinômio
plot_desemp <- ggpredict(modelo_final, terms = "txdesemp [all]", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Desemprego (Não-linear)",
    x = "Taxa de Desemprego (%)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# 3. Efeito da População (Quadrático)
# Plota a curvatura ajustada para o Log da População
plot_pop <- ggpredict(modelo_final, terms = "log_popres [all]", typical = 'mode') %>%
  plot() +
  labs(
    title = "Efeito do Tamanho da População",
    x = "Log(População)", 
    y = "Probabilidade de Alta Pobreza"
  ) +
  theme_light()

# Exibir os gráficos juntos usando gridExtra
# Organiza em 2 colunas: Analfabetismo e Desemprego na linha 1, População centralizada na linha 2
grid.arrange(plot_analfa, plot_desemp, plot_pop, ncol = 3, 
             layout_matrix = rbind(c(1, 2), c(3, 3)))



```

## Visualização 3D das Probabilidades
```{r visualizacao_3d, message=FALSE, warning=FALSE}

# 1. Preparar os dados com as predições
# Usamos os dados reais para ver onde os municípios se posicionam no espaço 3D
df_3d <- df_transf %>%
  mutate(
    prob_predita = predict(modelo_final, type = "response"),
    # Criamos um texto formatado para quando passar o mouse
    hover_text = paste(
      "<b>Município:</b>", municipio,
      "<br><b>Analfabetismo:</b>", txanalfa, "%",
      "<br><b>Desemprego:</b>", txdesemp, "%",
      "<br><b>População:</b>", exp(log_popres) %>% round(0), # Revertendo o log para ler fácil
      "<br><b>Prob. Alta Pobreza:</b>", scales::percent(prob_predita, accuracy = 0.1)
    )
  )

# 2. Gerar o Gráfico de Dispersão 3D
plot_ly(data = df_3d, 
        x = ~txanalfa, 
        y = ~txdesemp, 
        z = ~log_popres,
        color = ~prob_predita, 
        colors = c("#440154", "#21908C", "#FDE725"), # Escala Viridis (escura -> clara)
        type = "scatter3d", 
        mode = "markers",
        marker = list(
          size = 6,              # Tamanho das bolinhas
          opacity = 0.8,         # Transparência para ver pontos atrás
          line = list(width = 0) # Remove borda para ficar mais limpo
        ),
        text = ~hover_text,
        hoverinfo = "text"
) %>%
  layout(
    title = "Espaço Tridimensional dos Preditores<br><sub>Cor = Probabilidade de Alta Pobreza</sub>",
    scene = list(
      xaxis = list(title = "Analfabetismo (%)"),
      yaxis = list(title = "Desemprego (%)"),
      zaxis = list(title = "Log(População)"),
      camera = list(eye = list(x = 1.5, y = 1.5, z = 1.2)) # Posição inicial da câmera
    )
  )

```

## Visualização 3D de Acertos e Erros

```{r visualizacao_3d_acertos_erro, message=FALSE, warning=FALSE}

# 1. Preparar os dados de classificação
df_classificacao <- df_transf %>%
  mutate(
    # Probabilidade predita pelo modelo
    prob = predict(modelo_final, type = "response"),
    
    # Classificação baseada no limiar de 50% (0.5)
    # Se prob > 0.5 -> Classifica como "Alta Proporção" (nível 2 do fator)
    # Se prob <= 0.5 -> Classifica como "Baixa Proporção" (nível 1 do fator)
    classe_predita = ifelse(prob > 0.5, "Alta Proporção", "Baixa Proporção"),
    
    # Verificar se acertou ou errou
    # Como y_bin é fator, convertemos para caracter para comparar
    resultado = ifelse(as.character(y_bin) == classe_predita, "Acerto", "Erro"),
    
    # Detalhe do erro (Falso Positivo vs Falso Negativo) para o tooltip
    tipo_erro = case_when(
      resultado == "Acerto" ~ "Classificação Correta",
      classe_predita == "Alta Proporção" ~ "Falso Positivo (Predisse Alta, mas é Baixa)",
      TRUE ~ "Falso Negativo (Predisse Baixa, mas é Alta)"
    ),
    
    # Texto para o mouse
    hover_text = paste(
      "<b>Município:</b>", municipio,
      "<br><b>Analfabetismo:</b>", txanalfa, "%",
      "<br><b>Desemprego:</b>", txdesemp, "%",
      "<br><b>População:</b>", exp(log_popres) %>% round(0), # Revertendo o log para ler fácil
      "<br><b>Prob. Alta Pobreza:</b>", scales::percent(prob, accuracy = 0.1)
    )
  )

# 2. Gerar o Gráfico 3D
plot_ly(data = df_classificacao, 
        x = ~txanalfa, 
        y = ~txdesemp, 
        z = ~log_popres,
        color = ~resultado, 
        colors = c("#1f77b4", "#d62728"), # Azul para Acerto, Vermelho para Erro
        symbol = ~resultado,
        symbols = c("circle", "circle"), # Bolinha para Acerto, X para Erro
        type = "scatter3d", 
        mode = "markers",
        marker = list(
          size = 6,
          opacity = 0.8,
          line = list(width = 1, color = "black") # Borda para destacar
        ),
        text = ~hover_text,
        hoverinfo = "text"
) %>%
  layout(
    title = "Diagnóstico de Classificação 3D<br><sub>Pontos vermelhos indicam onde o modelo errou</sub>",
    scene = list(
      xaxis = list(title = "Analfabetismo (%)"),
      yaxis = list(title = "Desemprego (%)"),
      zaxis = list(title = "Log(População)")
    ),
    legend = list(title = list(text = "Resultado"))
  )


```

## Visualização da probabilidade conjunta 

```{r visualizacao_probabilidade_conjunta, message=FALSE, warning=FALSE, fig.width=15, fig.height=6}
# Definindo as medianas para fixar as variáveis de controle
med_analfa <- median(df_transf$txanalfa)
med_desemp <- median(df_transf$txdesemp)
med_pop    <- median(df_transf$log_popres)

# ----------------------------------------------------------------------------
# GRÁFICO 1: Analfabetismo vs Desemprego (Fixando População)
# ----------------------------------------------------------------------------
grid1 <- expand.grid(
  txanalfa = seq(min(df_transf$txanalfa), max(df_transf$txanalfa), length.out = 50),
  txdesemp = seq(min(df_transf$txdesemp), max(df_transf$txdesemp), length.out = 50),
  log_popres = med_pop
)
grid1$prob <- predict(modelo_final, newdata = grid1, type = "response")

p1 <- ggplot(grid1, aes(x = txanalfa, y = txdesemp)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) + # Pontos reais
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1)) +
  scale_color_manual(values = c("black", "darkred")) +
  labs(title = "Analfabetismo vs Desemprego", subtitle = "População fixa na mediana") +
  theme_minimal() + theme(legend.position = "none")

# ----------------------------------------------------------------------------
# GRÁFICO 2: Analfabetismo vs Log(População) (Fixando Desemprego)
# ----------------------------------------------------------------------------
grid2 <- expand.grid(
  txanalfa = seq(min(df_transf$txanalfa), max(df_transf$txanalfa), length.out = 50),
  log_popres = seq(min(df_transf$log_popres), max(df_transf$log_popres), length.out = 50),
  txdesemp = med_desemp
)
grid2$prob <- predict(modelo_final, newdata = grid2, type = "response")

p2 <- ggplot(grid2, aes(x = txanalfa, y = log_popres)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) +
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1)) +
  scale_color_manual(values = c("black", "darkred")) +
  labs(title = "Analfabetismo vs População", subtitle = "Desemprego fixo na mediana") +
  theme_minimal() + theme(legend.position = "none")

# ----------------------------------------------------------------------------
# GRÁFICO 3: Desemprego vs Log(População) (Fixando Analfabetismo)
# ----------------------------------------------------------------------------
grid3 <- expand.grid(
  txdesemp = seq(min(df_transf$txdesemp), max(df_transf$txdesemp), length.out = 50),
  log_popres = seq(min(df_transf$log_popres), max(df_transf$log_popres), length.out = 50),
  txanalfa = med_analfa
)
grid3$prob <- predict(modelo_final, newdata = grid3, type = "response")

p3 <- ggplot(grid3, aes(x = txdesemp, y = log_popres)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), color = "white", breaks = 0.5, size=0.8) +
  geom_point(data = df_transf, aes(color = y_bin), alpha = 0.3, size = 1.5) +
  scale_fill_gradient2(low = "#2c7bb6", mid = "#ffffbf", high = "#d7191c", midpoint = 0.5, limits=c(0,1), name="Prob.\nPredita") +
  scale_color_manual(values = c("black", "darkred"), name="Real") +
  labs(title = "Desemprego vs População", subtitle = "Analfabetismo fixo na mediana") +
  theme_minimal() + theme(legend.position = "right")

# ----------------------------------------------------------------------------
# Exibição Conjunta
# ----------------------------------------------------------------------------
# Organiza os 3 plots. O p3 fornece a legenda para todos.
grid.arrange(p1, p2, p3, ncol = 3)
```

# Diagnóstico do Ajuste

## Multicolinearidade (VIF)

```{r multicolinearidade, message=FALSE, warning=FALSE}
car::vif(modelo_final)
```

# Teste de Shapiro-Wilk
```{r shapiro_wilk, message=FALSE, warning=FALSE}
shapiro.test(residuals(modelo_final))
```
O GVIF, bem como o teste de Shapiro Wilk, confirmam que não há evidência de multicolinearidade entre as variáveis preditoras.

# Resíduos
```{r hnp, message=FALSE, warning=FALSE}

hnp(modelo_final, resid.type = "deviance", how.many.out = TRUE, paint.out = TRUE,
    main = "Envelope Simulado", xlab = "Percentil Teórico", ylab = "Resíduos Deviance")

```

```{r resíduos, message=FALSE, warning=FALSE}
plot(residuals(modelo_final))
```
